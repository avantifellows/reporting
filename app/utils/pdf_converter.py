import os
import requests
import base64
import mimetypes
from fastapi.responses import StreamingResponse, HTMLResponse
import re
from bs4 import BeautifulSoup


def convert_template_to_pdf(template_response, debug=False):
    """
    Convert a TemplateResponse to a PDF using the HTML-to-PDF server.
    NOTE: This is generated by AI (cursor), but has been tested and works.

    Args:
        template_response: The TemplateResponse to convert
        debug (bool): If True, returns the HTML content instead of sending to PDF service

    Returns:
        StreamingResponse: The PDF response if successful
        HTMLResponse: An error response if conversion fails or the HTML content if debug is True
    """
    html_content = template_response.body
    html_content = html_content.decode("utf-8")  # Decode bytes to string

    # Convert bytes to string if necessary
    if isinstance(html_content, bytes):
        html_content = html_content.decode()

    # Use BeautifulSoup to parse the HTML
    soup = BeautifulSoup(html_content, "html.parser")

    # Try to find and inline the CSS from file first
    css_added = False
    css_link = soup.find("link", href=re.compile(r"/static/style.css"))

    if css_link:
        # Define possible CSS file paths to try
        css_paths = [
            "static/style.css",
            "app/static/style.css",
            "../static/style.css",
            os.path.join(os.getcwd(), "static", "style.css"),
            os.path.join(os.getcwd(), "app", "static", "style.css"),
        ]

        # Print current working directory for debugging
        print(f"Current working directory: {os.getcwd()}")

        # Try each path until we find one that works
        for css_path in css_paths:
            try:
                print(f"Trying CSS path: {css_path}")
                with open(css_path, "r") as f:
                    css_content = f.read()

                # Add the CSS content as a style tag in the HTML
                style_tag = soup.new_tag("style")
                style_tag.string = css_content
                soup.head.append(style_tag)
                css_added = True
                print(f"CSS successfully added from file: {css_path}")
                break
            except FileNotFoundError:
                print(f"CSS file not found: {css_path}")
            except Exception as e:
                print(f"Error reading CSS file {css_path}: {str(e)}")

    # If we couldn't add CSS from file, add default CSS directly
    if not css_added:
        print("Using default inline CSS")
        # Default CSS that covers important styling for reports
        default_css = """
        html {
            height: 100%;
        }

        body {
            font-family: "Avenir", Arial, Helvetica, sans-serif;
            margin-left: auto;
            margin-right: auto;
            font-size: 14pt;
            text-align: center;
            height: 100%;
            margin-bottom: 25px;
        }

        #name_card,
        #total_stats_card {
            display: table;
            margin: 20px auto 0 auto;
            text-align: center;
            font-size: 18pt;
            background-color: #EAEDFD;
            border-radius: 8px;
            padding: 8px 25px;
            box-shadow: none;
            width: 40%;
        }

        #answer_sheet_button {
            display: table;
            margin: 30px auto 0 auto;
            text-align: center;
            font-size: 18pt;
            background-color: #29973E;
            border-radius: 3px;
            text-decoration: none;
            color: white;
            padding: 18px 60px;
            box-shadow: 1px 1px 5px #535353;
        }

        #test_summary_card,
        #report_header_card {
            display: inline-flex;
            margin-left: auto;
            margin-right: auto;
            margin-top: 30px;
            font-weight: bold;
            justify-content: center;
            background-color: #EBF5FE;
            border-radius: 8px;
            padding: 8px 25px;
            box-shadow: none;
            width: auto;
            max-width: 40%;
        }

        #test_summary_card .percentage {
            margin-right: 15px;
            justify-content: center;
            align-items: center;
            background: orange;
            border-radius: 50%;
            text-align: center;
            padding: 5px;
            aspect-ratio: 1;
            display: flex;
            font-size: 18pt;
        }

        #section_heading {
            padding: 8px;
            font-size: 24pt;
            font-weight: bold;
            margin-top: 30px;
            text-transform: uppercase;
        }

        #score_details,
        #daywise_stats {
            border-collapse: collapse;
            padding: 0 30px 0 30px;
            margin-left: auto;
            margin-right: auto;
            table-layout: fixed;
            margin-top: 30px;
            margin-bottom: 30px;
            width: 70%;
        }

        #score_details td,
        #daywise_stats td {
            padding: 10px 20px 10px 20px;
            font-size: 20pt;
            text-align: center;
        }

        #score_details tr:nth-child(even) {
            background-color: white;
        }

        #score_details tr:nth-child(odd) {
            background-color: orange;
        }

        #chapter_details tr:nth-child(even) {
            background-color: white;
        }

        #chapter_details tr:nth-child(odd) {
            background-color: #FEFBEB;
        }

        #chapter_details tr:first-child td {
            vertical-align: top;
            background-color: orange;
            color: black;
            font-weight: bold;
        }

        #message_section {
            width: 70%;
            margin: 30px auto;
            background-color: transparent;
        }

        .message {
            margin: 15px 0;
            font-size: 16pt;
            text-align: center;
        }

        .buttons_container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 30px;
            margin: 30px 0;
        }

        .button_wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
        }

        .help_text {
            color: #888;
            font-size: 14px;
            margin-top: 8px;
        }

        .answer_sheet_button {
            display: table;
            text-align: center;
            font-size: 20pt;
            background-color: #29973E;
            border-radius: 3px;
            text-decoration: none;
            color: white;
            padding: 18px 60px;
            box-shadow: 1px 1px 5px #535353;
        }
        """

        style_tag = soup.new_tag("style")
        style_tag.string = default_css
        soup.head.append(style_tag)

    # Fix image URLs - convert local images to base64
    imgs = soup.find_all("img")
    for img in imgs:
        src = img.get("src")
        if src and not src.startswith("http") and not src.startswith("data:"):
            # Define possible image paths to try
            img_paths = [
                os.path.join("static", src.lstrip("/")),
                os.path.join("app/static", src.lstrip("/")),
                os.path.join(os.getcwd(), "static", src.lstrip("/")),
                os.path.join(os.getcwd(), "app/static", src.lstrip("/")),
            ]

            for img_path in img_paths:
                try:
                    print(f"Trying image path: {img_path}")
                    mime_type, _ = mimetypes.guess_type(img_path)
                    if not mime_type:
                        mime_type = (
                            "image/png"  # Default to PNG if can't determine type
                        )

                    with open(img_path, "rb") as f:
                        img_data = f.read()
                        base64_data = base64.b64encode(img_data).decode("utf-8")
                        # Update the src attribute with base64 encoded image
                        img["src"] = f"data:{mime_type};base64,{base64_data}"
                        print(f"Image successfully converted: {img_path}")
                        break
                except (FileNotFoundError, IsADirectoryError):
                    print(f"Image file not found: {img_path}")
                except Exception as e:
                    print(f"Error processing image {img_path}: {str(e)}")

    # Get the modified HTML content
    modified_html = str(soup)

    # If debug mode is enabled, return the HTML content instead
    if debug:
        return HTMLResponse(content=modified_html, media_type="text/html")

    # Send the modified HTML to PDF rendering service
    url = os.getenv("HTML_TO_PDF_SERVER_URL")
    print(f"Sending HTML to PDF service at: {url}")
    response = requests.post(url, json={"html": modified_html})

    # Check if the request was successful
    if response.status_code == 200:
        print("PDF generation successful")
        # Return the PDF as a streaming response
        return StreamingResponse(
            response.iter_content(chunk_size=10240),
            media_type="application/pdf",
        )
    else:
        print(f"HTML to PDF service error: {response.status_code} - {response.text}")
        return HTMLResponse(content="Error generating PDF", status_code=500)
